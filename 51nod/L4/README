1574 
给你两个全排列，问你将一个全排列变为另外一个的最小代价。
每次可以任意选两个p_i,p_j交换，代价|i-j|
solution:
将一个全排列映射，等价与将一个打乱的全排列通过交换两个数排序复原,问最小的代价。计算所有的差值之和/2就可以了。
具体做法: 每次选择两个都不会越界的数交换,即可得到答案。
证明:
----------
1717:
好数，问1~N中有多少个数有偶数个因子。
solution:
只有完全平方数因子个数为奇数。
----------

1791:
给你一个括号序列，问其中有多少个合法的括号子段。

-------------
1829:
从A->B映射，问方案数．其中N,M<=1,000,000
要求B每个元素都被覆盖

------------
1076
给你一个无向图多次询问，x到y是否存在两条不相同的路径．
solutin:边双连通分量
------
1434
询问最小的M,使得LCM(1...N)|LCM(N+1...M)
solution:
-暴力求，不可取

- 快速求LCM(1...N) 可以O(N*C)求出,求中C为常数
- 考虑到最后的形式一定是2^a * 3^b * 5^c *...
  a为所有数字分解质因子后最大的,求出系数即可求
- 求LCM(N+1...M)是否整除LCM(1...N),二分M，用类似上面的方法判断


-----------------
1179 最大的最大公约数
询问N个数中,max(gcd(a_i,a_j))
solution:
将每个数分解质因子，复杂度:sqrt(M)
用一个数组cnt[i]记录一下，因子为i的数字有多少个即可
然后遍历一遍即可

-----------------------------
1108 空间中找一点到其他所有点的哈密顿距离之和最小
solution:
考虑到三个维度(x,y,z)互不干扰，我们只需要按照一个维度
做三次即可．
即，每一维度排序后选择中间点即可


---------------------------------
1105 第K大的数 好题
给你两个数组A[N],B[N],可以组成N^2个数A[i]*B[j]
求第K大的数
solution:
直接二分最后的答案(O(log(INT64))),然后统计一下有多少个数小于这个数O(N*logN)

---------------------------------
1103 N的倍数 容斥原理
给你N个数，要求你选择任意多个数，让其是N的倍数
solution:
首先，题目一定有解。从前缀和入手，因为有N个数，故有sum[0]...sum[N]，共N+1个
数，由于抽屉原理,一定存在一段[i,j]其前缀和相等。

Q:如果不是N的倍数，而是K的倍数呢?
A:就不能这样做，比如　a[]={1 3 4} K=5


-------------------------------------
1109 01组成N的倍数  好题
给一个自然数N，找出一个最小的自然数M，是N的倍数，且M的10进制表示只包含0或1。
(N<=1e6)
solution:
	考虑到最后10进制下只有0,1,那么我们直接将i从1开始往后枚举即可。
	将i转化为2进制下串x,再将串x当做10进制下数处理即可.
	for(i=1;;++i){
		to_decimal(i,s);
		if(isok(s))break;
	}
Q:复杂度?
A:我们可以知道10^x%p==1,如果x满足那么等式一定满足，可以把这个作为上界

Q:如果不是只包含0,1而是任意一些数呢，比如6,7,9?
A:将6,7,9分别当做0,1,2处理,然后转化，最后再做对应的映射即可


----------------------------------------
1191 消灭兔子  贪心
有N只兔子，有一个血量B[i];有M只箭，伤害值为D[i],价格为P[i]. (N,M<=5e4)
每只箭只能用一次，每只兔子只能射一次．问最小花费.
solution:
兔子按血量降序排列，首先将所有伤害>=当前兔子血量的箭加入一个优先队列，
然后取出价格最小的即可．

证明:
	首先，对于1只特定的兔子,如果它的血量固定，那么选取代价最小的肯定是没问题的．
	其次，如果箭头能够射血量大的，那么一定能够射血量小的
----------------------------
1605 博弈
solution:
考虑到每次取走的个数只能是奇数，故只需要考虑就行。

1441 数学，素数筛
多次询问[a,b]中a*...*b的因子个数。
solution:
f[i]:表示1*2*...*i的因子个数

---------------------------
1294 LIS,好题
将一个数组变为严格上升子序列的最小代价1
wrong solution:
dp[i][0]:代表第i位不修改变成严格上升子序列的最小代价
dp[i][1]:代表修改

solution:
首先可以明确一点,一个最小的严格递增的正整数子序列为1,2,3,..........n,那么对于题目给出的任何一个序列,需要最少改变多少个使得序列变为严格递增的子序列呢? 对于每一个数a[i],把a[i] 变为 a[i] - i,如果此时a[i]小于0,说明他连最小的严格递增子序列都不符合,那么它一定要修改,再处理完这些小于0的数后,剩下的数又应该怎么操作呢? 直接求出最长的非严格递增子序列就行
