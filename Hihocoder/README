1881
给你一棵树，询问所有(u,v)中最大的|val[u]-val[v]|,其中u,v存在祖先后代关系
max[u],min[u]:从根节点到u点的最大值与最小值


1964 dp+前缀和
给你一些N(N<=1e5)个线段 [s,e] <=1e6,选择最多的不想交线段,使得覆盖的点尽可能多.
solution:
f[i]:1...i区间最多可以覆盖多少点.
f[i]=f[j-1]+(i-j+1) if has segment[j,i]
f[i]=max(f[i],f[i-1])

1957 计算贡献,二分,瞎搞
f[i,j][k]:记为s[i...j]中出现次数<=k的字符数
abad
如f[0,3][1]=2,有b,d
求所有子串的f[l,r][k]的和
solution:
a: 1,3 
考虑a的贡献,即求包含a的不超过k个的区间数
前缀和+二分


1969 
N(N<=5000)个整数(a_i <= 1e6),从中选取M个组成等差数列,求M的最大值.
solution:

265_1
给你N条有向边,N个点.
问去掉那几条边之一，可以构成一个以1为根的有根树
solution:
考虑到树的性质，每个节点只有一个父节点．
找到父节点>=2的，或者子节点是1的那条边

hiho1678
版本号排序 ,重载小于符号
bool cmp(string now,string front){

}
now:当前元素,front前面一个元素
cmp返回true,代表交换;返回false代表不交换.
